name: 'openbsd_packet_filter-package-filter'
pipeline:
  - name: parsed_event
    external:
      name: grok.match
      properties:
        input_field: '{{original.message}}'
        output_field: message
        pattern: '%{PACKET_FILTER},(%{PF_IPV4}|%{PF_IPV6}),(%{PF_UDP}|%{PF_TCP}|%{PF_CARP}|%{PF_ICMP})'

        custom_patterns:
          PACKET_FILTER: '%{NUMBER:rulenr},%{DATA:subrulenr},%{DATA:anchorname},%{WORD:label},%{WORD:interface},%{WORD:reason},%{WORD:action},%{WORD:dir}'
          PF_IPV4: '4,%{WORD:tos},%{DATA:ecn},%{NUMBER:hoplimit},%{NUMBER:id},%{NUMBER:offset},%{WORD:flags},%{NUMBER:protonum},%{WORD:protoname},%{NUMBER:length},%{IPV4:src},%{IPV4:dst}'
          PF_IPV6: '6,%{DATA:class},%{DATA:flow},%{DATA:hoplimit},%{WORD:protoname},%{NUMBER:protonum},%{NUMBER:length},%{IPV6:src},%{IPV6:dst}'
          PF_UDP: '%{NUMBER:srcport},%{NUMBER:dstport},%{NUMBER:datalen}'
          PF_TCP: '%{NUMBER:srcport},%{NUMBER:dstport},%{NUMBER:datalen},%{WORD:tcp_flags},%{NUMBER:seq},%{DATA:ack},%{NUMBER:window},%{NUMBER:urg},%{GREEDYDATA:options}'
          PF_CARP: '%{DATA:type},%{NUMBER:hoplimit},%{DATA:vhid},%{DATA:version},%{DATA:advskew},%{DATA:advbase}'
          PF_ICMP: 'datalength=%{DATA:icmp_datalength}'

  - name: set_ecs_fields
stages:
  set_ecs_fields:
    actions:
      - set:
          source.ip: "{{parsed_event.message.src}}"
          destination.ip: "{{parsed_event.message.dst}}"
          rule.id: "{{parsed_event.message.rulenr}}"
          openbsd_packet_filter.pf.rule.subrulenr: "{{parsed_event.message.subrulenr}}"
          rule.ruleset: "{{parsed_event.message.anchorname}}"
          openbsd_packet_filter.pf.event.tracker.id: "{{parsed_event.message.label}}"
          event.reason: "{{parsed_event.message.reason}}"
          event.action: "{{parsed_event.message.action}}"
          network.direction: "{{parsed_event.message.dir}}"
          openbsd_packet_filter.pf.routing.class: "{{parsed_event.message.tos}}"
          openbsd_packet_filter.pf.routing.hoplimit: "{{parsed_event.message.hoplimit}}"
          openbsd_packet_filter.pf.routing.offset: "{{parsed_event.message.offset}}"
          openbsd_packet_filter.pf.routing.flags: "{{parsed_event.message.flags}}"
          network.iana_number: "{{parsed_event.message.protonum}}"
          network.transport: "{{parsed_event.message.protoname}}"
          network.bytes: "{{parsed_event.message.length}}"
          source.port: "{{parsed_event.message.srcport}}"
          destination.port: "{{parsed_event.message.dstport}}"
          openbsd_packet_filter.pf.transport.bytes: "{{parsed_event.message.datalen}}"
          openbsd_packet_filter.pf.transport.tcp_flags: "{{parsed_event.message.tcp_flags}}"
          openbsd_packet_filter.pf.transport.sequence_number: "{{parsed_event.message.seq}}"
          openbsd_packet_filter.pf.transport.ack: "{{parsed_event.message.ack}}"
          openbsd_packet_filter.pf.transport.window_size: "{{parsed_event.message.window}}"
          openbsd_packet_filter.pf.transport.urgency: "{{parsed_event.message.urg}}"
          openbsd_packet_filter.pf.transport.options: "{{parsed_event.message.option}}"
          openbsd_packet_filter.pf.ipv6.classification: "{{parsed_event.message.class}}"
          openbsd_packet_filter.pf.carp.vhid: "{{parsed_event.message.vhid}}"
          openbsd_packet_filter.pf.carp.version: "{{parsed_event.message.version}}"
          openbsd_packet_filter.pf.carp.advskew: "{{parsed_event.message.advskew}}"
          openbsd_packet_filter.pf.carp.advbase: "{{parsed_event.message.advbase}}"
          openbsd_packet_filter.pf.icmp.datalength: "{{parsed_event.message.datalength}}"
          openbsd_packet_filter.pf.routing.flow: "{{parsed_event.message.flow}}"
          openbsd_packet_filter.pf.carp.type: "{{parsed_event.message.type}}"

      - set:
          event.kind: 'event'
          event.category: ['network']
          event.type: ['connection']

      - translate:
        dictionary:
          "block": ["denied"]
          "pass": ["allowed"]
        mapping:
          parsed_event.message.action: event.type
        fallback: ["info"]


      - set:
          observer.ingress.interface.name: "{{parsed_event.message.interface}}"
        filter: "{{parsed_event.message.dir == 'in'}}"

      - set:
          observer.egress.interface.name: "{{parsed_event.message.interface}}"
        filter: "{{parsed_event.message.dir == 'out'}}"

      - translate:
        dictionary:
          'in': 'inbound'
          'out': 'outbound'
        mapping:
          parsed_event.message.direction: network.direction

